<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>DodgeCat</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<style>
  body {
    background: black;
    color: white;
    font-family: monospace;
    text-align: center;
    user-select: none;
    display: flex;
    flex-direction: column;
    align-items: center;
    height: 100vh;
    margin: 0;
    touch-action: none;
    overflow: hidden;
    box-sizing: border-box;
  }

  #gameContainer {
    display: flex;
    flex-direction: column;
    align-items: center;
    transform-origin: top center;
  }

  canvas {
    display: block;
    touch-action: none;
  }

  #spriteCanvas {
    margin-top: 20px;
    margin-bottom: 20px;
    background: black;
    display: block;
    margin-left: auto;
    margin-right: auto;
  }

  #timer, #status {
    font-size: 18px;
    margin-top: 10px;
  }

  #status ol {
    font-size: 14px;
    padding-left: 20px;
    margin: 5px 0;
  }

  button {
    display: none;
    padding: 6px 14px;
    background: white;
    color: black;
    border: none;
    font-weight: bold;
    border-radius: 4px;
    cursor: pointer;
    margin: 2px;
  }

  button:hover {
    background: #ccc;
  }
  
  #versionText {
    font-size: 14px;
    color: white;
    margin: 4px 0; 
    text-align: center;
  font-family: monospace;
  }
  
</style>
</head>
<body>

<div id="gameContainer">
  <canvas id="spriteCanvas"></canvas>
  <div id="versionText">Version 0.3 Alpha</div>
  <canvas id="game" width="300" height="300"></canvas>
  <div>
    <button id="startBtn">Start</button>
    <button id="restartBtn">Restart</button>
  </div>
  <div id="timer">Time: 0.0s</div>
  <div id="status"></div>
</div>

<script>
/* ---------------- PIXEL SPRITE ---------------- */
const spriteData = `
xxxxxxxxxx..............xxxxxxxxxxxxxx......xxxxxxxxxx................xxxxxxxxxx........xxxxxxxxxxxxxxxxxx....xxxxxxxxxxxxxxxxxx....xxxxxxxxxxxxxxxxxx....xxxxxxxxxxxxxxxxxx
xxxxxxxxxxxx............xxxxxxxxxxxxxx......xxxxxxxxxxxx............xxxxxxxxxxxxxx......xxxxxxxxxxxxxxxxxx....xxxxxxxxxxxxxxxxxx....xxxxxxxxxxxxxxxxxx....xxxxxxxxxxxxxxxxxx
xx........xxxx........xxxx..........xxxx....xx........xxxx........xxxx..........xxxx....xx....................xx..............xx....xx..............xx............xx........
xx..........xxxx......xx..............xx....xx..........xxxx......xx..............xx....xx....................xx..............xx....xx..............xx............xx........
xx............xxxx....xx..............xx....xx............xxxx....xx..............xx....xx....................xx..............xx....xx..............xx............xx........
xx..............xx....xx..............xx....xx..............xx....xx..............xx....xx....................xx..............xx....xx..............xx............xx........
xx..............xx....xx..............xx....xx..............xx....xx..............xx....xx....................xx....................xx..............xx............xx........
xx..............xx....xx..............xx....xx..............xx....xx..............xx....xx....................xx....................xx..............xx............xx........
xx..............xx....xx..............xx....xx..............xx....xx..............xx....xx....................xx....................xx..............xx............xx........
xx..............xx....xx..............xx....xx..............xx....xx..............xx....xx....................xx....................xx..............xx............xx........
xx..............xx....xx..............xx....xx..............xx....xx..............xx....xx....................xx....................xx..............xx............xx........
xx..............xx....xx..............xx....xx..............xx....xx..............xx....xx....................xx....................xx..............xx............xx........
xx..............xx....xx..............xx....xx..............xx....xx..............xx....xx....................xx....................xx..............xx............xx........
xx..............xx....xx..............xx....xx..............xx....xx..............xx....xx....................xx....................xx..............xx............xx........
xx..............xx....xx..............xx....xx..............xx....xx....................xxxxxxxxxxxxxxxxxx....xx....................xxxxxxxxxxxxxxxxxx............xx........
xx..............xx....xx..............xx....xx..............xx....xx....................xxxxxxxxxxxxxxxxxx....xx....................xxxxxxxxxxxxxxxxxx............xx........
xx..............xx....xx..............xx....xx..............xx....xx........xxxxxxxx....xx....................xx....................xx..............xx............xx........
xx..............xx....xx..............xx....xx..............xx....xx........xxxxxxxx....xx....................xx....................xx..............xx............xx........
xx..............xx....xx..............xx....xx..............xx....xx..............xx....xx....................xx....................xx..............xx............xx........
xx..............xx....xx..............xx....xx..............xx....xx..............xx....xx....................xx....................xx..............xx............xx........
xx..............xx....xx..............xx....xx..............xx....xx..............xx....xx....................xx....................xx..............xx............xx........
xx..............xx....xx..............xx....xx..............xx....xx..............xx....xx....................xx....................xx..............xx............xx........
xx..............xx....xx..............xx....xx..............xx....xx..............xx....xx....................xx....................xx..............xx............xx........
xx..............xx....xx..............xx....xx..............xx....xx..............xx....xx....................xx....................xx..............xx............xx........
xx..............xx....xx..............xx....xx..............xx....xx..............xx....xx....................xx..............xx....xx..............xx............xx........
xx............xxxx....xx..............xx....xx............xxxx....xx..............xx....xx....................xx..............xx....xx..............xx............xx........
xx..........xxxx......xx..............xx....xx..........xxxx......xx..............xx....xx....................xx..............xx....xx..............xx............xx........
xx........xxxx........xxxx..........xxxx....xx........xxxx........xxxx..........xxxx....xx....................xx..............xx....xx..............xx............xx........
xxxxxxxxxxxx............xxxxxxxxxxxxxx......xxxxxxxxxxxx............xxxxxxxxxxxxxx......xxxxxxxxxxxxxxxxxx....xxxxxxxxxxxxxxxxxx....xx..............xx............xx........
xxxxxxxxxx..............xxxxxxxxxxxxxx......xxxxxxxxxx................xxxxxxxxxx........xxxxxxxxxxxxxxxxxx....xxxxxxxxxxxxxxxxxx....xx..............xx............xx........
`;

const spriteRows = spriteData.split("\n");
const spriteCols = Math.max(...spriteRows.map(row => row.length));
const pixelSize = 2;
const spriteWidth = spriteCols * pixelSize;
const spriteHeight = spriteRows.length * pixelSize;

const spriteCanvas = document.getElementById("spriteCanvas");
spriteCanvas.width = spriteWidth;
spriteCanvas.height = spriteHeight;
const spriteCtx = spriteCanvas.getContext("2d");

spriteRows.forEach((row, y) => {
  for (let x = 0; x < row.length; x++) {
    if (row[x] === "x") {
      spriteCtx.fillStyle = "white";
      spriteCtx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
    }
  }
});

/* ---------------- SCALE FOR ALL DEVICES ---------------- */
function scaleGameContainer() {
  const container = document.getElementById("gameContainer");
  const maxWidth = window.innerWidth * 0.95;
  const maxHeight = window.innerHeight * 0.95;

  const gameWidth = Math.max(spriteCanvas.width, 300);
  const gameHeight = spriteCanvas.height + 300 + 150;

  const scale = Math.min(maxWidth / gameWidth, maxHeight / gameHeight, 1);
  container.style.transform = `scale(${scale})`;
  container.style.transformOrigin = "top center";
}
window.addEventListener("resize", scaleGameContainer);
scaleGameContainer();

/* ---------------- GAME CODE ---------------- */
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const statusText = document.getElementById("status");
const restartBtn = document.getElementById("restartBtn");
const startBtn = document.getElementById("startBtn");

const boxSize = 260;
const boxOffset = (canvas.width - boxSize) / 2;
const playerSize = 15;
const projectileSize = 4;

const idleDesign = [
"xx....xxx.....","x.x..x..x.....","x..xx...x.....","x.......x.....","x.......x.....",
"x.x.x...x.....","x.x.x...x...xx","x..x....x..x.x","x.......xx.x.x",".x.....x..x..x",
"..x........xx.","..x........x..","..x.x.x..x.x..","..x.x.xxxx.x..","..xxxxx.xxxx.."
];

const movingLeftDesign = [
".x...x.....x..",".xx.xx....x...",".x.x.x.....x..","x.x.x.x.....x.","x.x.x.x....x..",
"x.....x....x..",".xxxxx.....x..","...x..xxxxx...","...x......x...",
"..x.......xx..",".xxxxxxxxxxxx.",".x..x....x..x.","x...x....x..x.",
"x..x....x....x","x..x....x....x"
];

const movingRightDesign = [
"..x.....x...x.","...x....xx.xx.","..x.....x.x.x.",".x.....x.x.x.x","..x....x.x.x.x",
"..x....x.....x","..xxxxx.....x.","...xxxxx..x...","...x......x...",
"..xx.......x..",".xxxxxxxxxxxx.",".x..x....x..x.","x..x....x...x.",
"x....x....x..x","x....x....x..x"
];

const shieldSprite = [
  "....x.....",
  ".....x....",
  "....x.xx..",
  "x..x....x.",
  ".xx......x",
  ".xx......x",
  "x..x....x.",
  "....x.xx..",
  ".....x....",
  "....x....."
];

let player, projectiles, openings, keys;
let timeSurvived, gameOver, projectileSpeed, spawnInterval, lastSpawn, lastTime;
let highScores = [];
let shield = {
  active: false,
  visible: false, 
  x: 0,
  y: 0,
  size: 10,  
  timer: 0,    
  duration: 0 
};

function resetGame() {
  player = { x: canvas.width/2, y: canvas.height/2, color: "white" };
  projectiles = [];
  openings = [];
  resetShield();
  keys = {};
  timeSurvived = 0;
  gameOver = false;
  projectileSpeed = 2;
  spawnInterval = 2000;
  lastSpawn = 0;
  lastTime = Date.now();
  statusText.innerHTML = "";
  restartBtn.style.display = "none";
  startBtn.style.display = "none";
  document.getElementById("timer").style.display = "block";
  requestAnimationFrame(loop);
}

function getMovementDesign() {
  if (keys["ArrowLeft"] || keys["a"]) return movingLeftDesign;
  if (keys["ArrowRight"] || keys["d"]) return movingRightDesign;
  return idleDesign;
}

function drawPlayer() {
  const design = getMovementDesign();
  for (let row = 0; row < design.length; row++) {
    for (let col = 0; col < design[row].length; col++) {
      if (design[row][col] === "x") {
        ctx.fillStyle = player.color;
        ctx.fillRect(player.x - playerSize/2 + col, player.y - playerSize/2 + row, 1, 1);
      }
    }
  }
}

function drawBox() {
  ctx.strokeStyle = "white";
  ctx.lineWidth = 2;
  ctx.strokeRect(boxOffset, boxOffset, boxSize, boxSize);

  openings.forEach(o => {
    ctx.strokeStyle = "black";
    ctx.lineWidth = 4;
    if (o.side === "top" || o.side === "bottom") {
      ctx.beginPath();
      ctx.moveTo(o.pos - 5, o.side === "top" ? boxOffset : boxOffset + boxSize);
      ctx.lineTo(o.pos + 5, o.side === "top" ? boxOffset : boxOffset + boxSize);
      ctx.stroke();
    } else {
      ctx.beginPath();
      ctx.moveTo(o.side === "left" ? boxOffset : boxOffset + boxSize, o.pos - 5);
      ctx.lineTo(o.side === "left" ? boxOffset : boxOffset + boxSize, o.pos + 5);
      ctx.stroke();
    }
  });
}

function spawnProjectile() {
  const sides = ["top", "bottom", "left", "right"];
  const side = sides[Math.floor(Math.random() * sides.length)];
  const numToSpawn = 3 + Math.floor(timeSurvived / 10);

  for (let i = 0; i < numToSpawn; i++) {
    const delay = i * 100;
    setTimeout(() => {
      let x, y, vx, vy, pos;
      if (side === "top") { x = boxOffset + Math.random() * boxSize; y = boxOffset; vx = 0; vy = projectileSpeed; pos = x; }
      else if (side === "bottom") { x = boxOffset + Math.random() * boxSize; y = boxOffset + boxSize; vx = 0; vy = -projectileSpeed; pos = x; }
      else if (side === "left") { x = boxOffset; y = boxOffset + Math.random() * boxSize; vx = projectileSpeed; vy = 0; pos = y; }
      else { x = boxOffset + boxSize; y = boxOffset + Math.random() * boxSize; vx = -projectileSpeed; vy = 0; pos = y; }

      openings.push({ side, pos, lastUsed: Date.now() });
      projectiles.push({ x, y, vx, vy });
    }, delay);
  }
}

function spawnShield() {
  const margin = boxOffset + 50;
  const maxX = boxOffset + boxSize - 50;
  const maxY = boxOffset + boxSize - 50;
  
  shield.x = margin + Math.random() * (maxX - margin);
  shield.y = margin + Math.random() * (maxY - margin);
  shield.visible = true;
  shield.timer = 0;
}

function updatePlayer() {
  const speed = 3;
  let dx = 0, dy = 0;
  if (keys["ArrowUp"] || keys["w"]) dy -= 1;
  if (keys["ArrowDown"] || keys["s"]) dy += 1;
  if (keys["ArrowLeft"] || keys["a"]) dx -= 1;
  if (keys["ArrowRight"] || keys["d"]) dx += 1;

  if (dx !== 0 || dy !== 0) {
    const len = Math.sqrt(dx*dx + dy*dy);
    dx = dx / len * speed;
    dy = dy / len * speed;
  }

  player.x += dx;
  player.y += dy;

  const min = boxOffset + playerSize/2;
  const max = boxOffset + boxSize - playerSize/2;
  player.x = Math.max(min, Math.min(max, player.x));
  player.y = Math.max(min, Math.min(max, player.y));
}

function updateProjectiles() {
  const newOpenings = [];
  projectiles = projectiles.filter(p => {
    p.x += p.vx;
    p.y += p.vy;
    let exited = false;
    if (p.vy > 0 && p.y >= boxOffset + boxSize) { newOpenings.push({ side: "bottom", pos: p.x, lastUsed: Date.now() }); exited = true; }
    else if (p.vy < 0 && p.y <= boxOffset) { newOpenings.push({ side: "top", pos: p.x, lastUsed: Date.now() }); exited = true; }
    else if (p.vx > 0 && p.x >= boxOffset + boxSize) { newOpenings.push({ side: "right", pos: p.y, lastUsed: Date.now() }); exited = true; }
    else if (p.vx < 0 && p.x <= boxOffset) { newOpenings.push({ side: "left", pos: p.y, lastUsed: Date.now() }); exited = true; }
	
	// Check for shield absorption (only if active)
    if (shield.active) {
      const dx = p.x - shield.x;
      const dy = p.y - shield.y;
      const absX = Math.abs(dx);
      const absY = Math.abs(dy);
      const halfSize = 15;
      const outline = 1;

      const withinBox = absX <= halfSize && absY <= halfSize;
      const onOutline = Math.abs(absX - halfSize) <= outline || Math.abs(absY - halfSize) <= outline;

      if (withinBox && onOutline) {
        exited = true; // remove projectile, absorbed by shield
      }
    }

    return !exited;
  });
  openings.push(...newOpenings);
}

function updateShield(delta) {
  // If shield inactive and invisible, count up until eligible to spawn
  if (!shield.visible && !shield.active) {
    shield.timer += delta;
    if (shield.timer > 30) {
      // After 30 seconds, random chance to spawn (about once every 10s)
      if (Math.random() < delta / 10) {
        spawnShield();
      }
    }
  }

  // If active, count down its lifespan
  if (shield.active) {
    shield.timer += delta;
    if (shield.timer > shield.duration) {
      shield.active = false;
      shield.timer = 0;
    }
  }

  // Detect pickup by player
  if (shield.visible) {
    const dx = player.x - shield.x;
    const dy = player.y - shield.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < playerSize / 2 + shield.size / 2) {
      activateShield();
    }
  }
  
  if (shield.visible && shield.timer > 10) {
    shield.visible = false;
    shield.timer = 0;
  }
}

function activateShield() {
  shield.visible = false;
  shield.active = true;
  shield.timer = 0;
  
  shield.duration = 5 + Math.random() * 5; // 5–10 seconds
  //shield.duration = 99999; //for testing game state
}

function resetShield() {
  shield = {
    active: false,
    visible: false,
    x: 0,
    y: 0,
    size: 10,
    timer: 0,
    duration: 0
  };
}

function checkCollision() {
  for (const p of projectiles) {
    if (Math.abs(p.x - player.x) < (playerSize/2 + projectileSize/2) &&
        Math.abs(p.y - player.y) < (playerSize/2 + projectileSize/2)) {
      gameOver = true;
      player.color = "red";
    }
  }
}

function cleanupOpenings() {
  openings = openings.filter(o => Date.now() - o.lastUsed < 1000);
}

function drawProjectiles() {
  ctx.fillStyle = "white";
  projectiles.forEach(p => {
    ctx.fillRect(p.x - projectileSize/2, p.y - projectileSize/2, projectileSize, projectileSize);
  });
}

function drawShield() {

  if (shield.visible) {
    const scale = 1 + 0.1 * Math.sin(Date.now() / 300); // pulsates between 0.9 and 1.1
    const pixelSize = (shield.size * scale) / 10; // scale sprite to shield.size with pulse
	
    ctx.fillStyle = "cyan";

    for (let row = 0; row < shieldSprite.length; row++) {
      for (let col = 0; col < shieldSprite[row].length; col++) {
        if (shieldSprite[row][col] === "x") {
          ctx.fillRect(
            shield.x - shield.size / 2 + col * pixelSize,
            shield.y - shield.size / 2 + row * pixelSize,
            pixelSize,
            pixelSize
          );
        }
      }
    }
  }

  if (shield.active) {
    // Draw faint interior (always visible)
    ctx.fillStyle = "rgba(0,255,255,0.1)";
    ctx.fillRect(shield.x - 14, shield.y - 14, 28, 28);

    // Decide if outline should blink
    let drawOutline = true;
    if (shield.duration - shield.timer <= 3) {
      drawOutline = Math.floor(shield.timer) % 2 === 0; // blink every second
    }

    if (drawOutline) {
      ctx.strokeStyle = "cyan";
      ctx.lineWidth = 1;
      ctx.strokeRect(shield.x - 15, shield.y - 15, 30, 30);
    }
  }

}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawBox();
  drawPlayer();
  drawProjectiles();
  drawShield();
}

function loop() {
  const now = Date.now();
  const delta = (now - lastTime)/1000;
  lastTime = now;

  if (gameOver) {
    openings = [];
    document.getElementById("timer").style.display = "none";

    highScores.push(timeSurvived);
    highScores.sort((a,b)=>b-a);
    if (highScores.length>5) highScores.length=5;

    let scoreHTML = '<div style="color:red;font-size:20px;">GAME OVER</div>';
    scoreHTML += `<div>Time survived: ${timeSurvived.toFixed(1)}s</div>`;
    scoreHTML += '<div style="margin-top:8px;"><strong>Top 5 Scores</strong></div><ol>';
    highScores.forEach(s=>scoreHTML+=`<li>${s.toFixed(1)}s</li>`);
    scoreHTML += '</ol>';

    statusText.innerHTML = scoreHTML;
    restartBtn.style.display="inline-block";
    return;
  }

  updatePlayer();
  if(now-lastSpawn>spawnInterval){spawnProjectile();lastSpawn=now;}

  updateProjectiles();
  checkCollision();
  cleanupOpenings();

  timeSurvived += delta;
  document.getElementById("timer").textContent=`Time: ${timeSurvived.toFixed(1)}s`;

  projectileSpeed = 0.2*Math.min(5,2+Math.sqrt(timeSurvived)*0.3);
  spawnInterval = Math.max(500,2000-Math.sqrt(timeSurvived)*70);
  
  updateShield(delta);

  draw();
  requestAnimationFrame(loop);
}

window.addEventListener("keydown", e=>keys[e.key]=true);
window.addEventListener("keyup", e=>keys[e.key]=false);

canvas.addEventListener("touchstart", handleTouch);
canvas.addEventListener("touchmove", handleTouch);
canvas.addEventListener("touchend", ()=>{ keys = {}; });

function handleTouch(e){
  e.preventDefault(); // prevent scrolling
  keys = {};
  const rect = canvas.getBoundingClientRect();

  for (let t of e.touches) {
    const touchX = t.clientX - rect.left;
    const touchY = t.clientY - rect.top;

    const dx = touchX - player.x;
    const dy = touchY - player.y;

    // Normalize movement
    const len = Math.sqrt(dx*dx + dy*dy);
    if (len > 0) {
      keys["ArrowRight"] = dx > 0;
      keys["ArrowLeft"] = dx < 0;
      keys["ArrowDown"] = dy > 0;
      keys["ArrowUp"] = dy < 0;
    }
  }
}

restartBtn.addEventListener("click", resetGame);
startBtn.addEventListener("click", resetGame);
startBtn.style.display="inline-block";
</script>
</body>
</html>
